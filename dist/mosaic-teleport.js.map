{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap b4893a9c1011bb8630a2","webpack:///./src/index.js","webpack:///external \"mosaic-commons\"","webpack:///external \"underscore\"","webpack:///external \"superagent\"","webpack:///./src/HttpClient.js","webpack:///./src/ApiDescriptor.js","webpack:///./src/ApiDispatcher.js","webpack:///./src/PathMapper.js","webpack:///./src/HttpClientSuperagent.js"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,wC;;;;;;;ACtCA;AACA;AACA;AACA,kCAEA;AACA;AACA,mEAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;;;ACvBD,gD;;;;;;ACAA,gD;;;;;;ACAA,gD;;;;;;ACAA;AACA;AACA;AACA,kCAEA,yGAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B;AAC5B;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;;AAEA;AACA,EAAC;;;;;;;AC9ID;AACA;AACA;AACA,kCAEA,yJAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;AACA;AACA,cAAa;AACb;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB,kBAAiB;AACjB;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB,kBAAiB;AACjB;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC;AAChC,wEAAuE;AACvE;AACA;AACA;AACA;AACA,wDAAuD;AACvD,gDAA+C;AAC/C,0DAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA;AACA,cAAa;AACb,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B;AAC9B,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;;AAEA;AACA,EAAC;;;;;;;ACvkBD;AACA;AACA;AACA,kCAEA;AACA,mFAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;AACA;AACA;AACA,cAAa;AACb,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;AACA,cAAa;AACb,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,EAAC;;;;;;;ACzLD;AACA;AACA;AACA,kCAEA,yGAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,EAAC,gJ;;;;;;AChLD;AACA;AACA;AACA,kCAEA,iIAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC,oCAAmC;AACnC,mCAAkC;AAClC;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA6D;AAC7D;AACA,sBAAqB;AACrB;AACA,sBAAqB;AACrB;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA,MAAK;;AAEL;AACA,EAAC","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"mosaic-commons\"), require(\"underscore\"), require(\"superagent\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"mosaic-commons\", \"underscore\", \"superagent\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mosaic-teleport\"] = factory(require(\"mosaic-commons\"), require(\"underscore\"), require(\"superagent\"));\n\telse\n\t\troot[\"mosaic-teleport\"] = factory(root[\"mosaic-commons\"], root[\"underscore\"], root[\"superagent\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap b4893a9c1011bb8630a2\n **/","if (typeof define !== 'function') {\n    var define = require('amdefine')(module);\n}\ndefine(\n// Dependencies\n[ 'require', 'mosaic-commons', './HttpClient', './ApiDescriptor',\n        './ApiDispatcher', './PathMapper', './HttpClient',\n        './HttpClientSuperagent' ],\n// Module\nfunction(require) {\n    var _ = require('underscore');\n    var HttpClient = require('./HttpClient');\n    var Superagent = require('superagent');\n    var Mosaic = require('mosaic-commons');\n    var Teleport = Mosaic.Teleport = {\n        ApiDescriptor : require('./ApiDescriptor'),\n        ApiDispatcher : require('./ApiDispatcher'),\n        PathMapper : require('./PathMapper'),\n        HttpClient : require('./HttpClient'),\n        HttpClientSuperagent : require('./HttpClientSuperagent')\n    };\n    Teleport.HttpClient.Superagent = Teleport.HttpClientSuperagent;\n    return Teleport;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"mosaic-commons\"\n ** module id = 1\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"underscore\"\n ** module id = 2\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"superagent\"\n ** module id = 3\n ** module chunks = 0\n **/","if (typeof define !== 'function') {\n    var define = require('amdefine')(module);\n}\ndefine(\n// Dependencies\n[ 'require', 'underscore', 'mosaic-commons' ],\n// Module\nfunction(require) {\n\n    var Mosaic = require('mosaic-commons');\n    var Class = Mosaic.Class;\n    var Errors = Mosaic.Errors;\n    var P = Mosaic.P;\n    var _ = require('underscore');\n\n    /** A generic HTTP client wrapper. */\n    var HttpClient = Class.extend({\n\n        /**\n         * Initializes this class.\n         * \n         * @param options.baseUrl\n         *            a base URL of the HTTP client\n         */\n        initialize : function(options) {\n            this.setOptions(options);\n            if (!this.options.baseUrl) {\n                throw Errors.newError('The \"baseUrl\" is not defined.')\n                        .code(501);\n            }\n        },\n\n        /**\n         * Creates a new request and response and executes this request. This\n         * method returns a promise with the result of the execution.\n         */\n        exec : function(options) {\n            var req = this.newRequest(options);\n            var res = this.newResponse(req);\n            return this.handle(req, res);\n        },\n\n        /**\n         * Handles the specified request to the remote API method and returns a\n         * promise with the response.\n         */\n        handle : function(req, res) {\n            var that = this;\n            var defer = P.defer();\n            try {\n                that.http(req, res, function(error) {\n                    try {\n                        if (!error) {\n                            var category = parseInt(res.status) / 100;\n                            category = parseInt(category) * 100;\n                            if (category != 200) {\n                                if (res.body && res.body.trace) {\n                                    error = Errors.fromJSON(res.body).code(\n                                            res.status);\n                                    var trace = _.isArray(res.body.trace) ? // \n                                    res.body.trace.join('\\n') : //\n                                    '' + res.body.trace;\n                                    error.stack = trace + '\\n\\n' + error.stack;\n                                } else {\n                                    error = Errors.newError(\n                                            'Error: ' + res.status).code(\n                                            res.status);\n                                }\n                            }\n                        }\n                        if (error) {\n                            throw error;\n                        }\n                        defer.resolve(res.body);\n                    } catch (err) {\n                        defer.reject(err);\n                    }\n                });\n            } catch (error) {\n                defer.reject(error);\n            }\n            return defer.promise;\n        },\n\n        /**\n         * Create a request object containing URL to invoke, method to invoke,\n         * query parameters, HTTP headers and the main body.\n         */\n        newRequest : function(options) {\n            options = options || {};\n            options.id = _.uniqueId('req-');\n            options.method = (options.method || 'get').toUpperCase();\n            options.params = options.params || {};\n            options.body = options.body || options.params || {};\n            options.url = this._toUrl(options.path);\n            options.query = options.query || {};\n            options.headers = options.headers || {};\n            return options;\n        },\n\n        /**\n         * Creates and returns a new response object corresponding to the\n         * specified request.\n         */\n        newResponse : function(req) {\n            return {\n                id : req.id,\n                status : 200,\n                headers : {},\n                body : null,\n                error : null\n            };\n        },\n\n        /**\n         * Transforms the specified path to the full URL. This method uses the\n         * \"baseUrl\" parameter defined in the constructor to build the full\n         * endpoint URL.\n         */\n        _toUrl : function(path) {\n            var options = this.options || {};\n            var baseUrl = options.baseUrl || '';\n            return baseUrl + path;\n        },\n\n        /**\n         * This method should implement a real HTTP call and return results\n         * using the specified callback method. First parameter of this callback\n         * is an error and the second parameter is the result of the call. This\n         * method should be overloaded in subclasses.\n         */\n        http : function(req, res, callback) {\n            var err = Errors.newError('Not implemented');\n            callback(err);\n        },\n    });\n\n    HttpClient.newInstance = function(options) {\n        return new HttpClient.Superagent(options);\n    };\n\n    return HttpClient;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/HttpClient.js\n ** module id = 4\n ** module chunks = 0\n **/","if (typeof define !== 'function') {\n    var define = require('amdefine')(module);\n}\ndefine(\n// Dependencies\n[ 'require', 'underscore', 'mosaic-commons', './PathMapper', './HttpClient' ],\n// Module\nfunction(require) {\n\n    var Mosaic = require('mosaic-commons');\n    var Class = Mosaic.Class;\n    var Errors = Mosaic.Errors;\n    var P = Mosaic.P;\n\n    var _ = require('underscore');\n    var PathMapper = require('./PathMapper');\n    var HttpClient = require('./HttpClient');\n\n    /**\n     * This descriptor defines API instance methods and their mapping to HTTP\n     * URLs and parameters.\n     */\n    var ApiDescriptor = Class.extend({\n\n        /** Initializes this instance */\n        initialize : function() {\n            this._config = {};\n            this._mapper = new PathMapper();\n        },\n\n        /**\n         * Defines a new API method, the corresponding REST path and the\n         * corresponding HTTP method (GET, POST, PUT, DELETE...)\n         * \n         * @param path\n         *            path of the endpoint corresponding to this API method;\n         *            this path can contain parameters (like\n         *            '/users/:userId/name') which are automatically transformed\n         *            to/from method arguments.\n         * @param http\n         *            name of the HTTP method used to invoke this API function\n         *            (GET, POST, PUT, DELETE...)\n         * @param method\n         *            the name of the API function to invoke\n         * \n         */\n        add : function(path, http, method, options) {\n            var obj = {\n                path : normalizePath(path),\n                http : http,\n                method : method\n            };\n            if (options) {\n                obj.options = options;\n            }\n            var conf = this._config[obj.path] = this._config[obj.path] || {};\n            conf[http] = obj;\n            this._mapper.add(obj.path, conf);\n            return this;\n        },\n\n        /**\n         * Returns a description of the method to invoke corresponding to the\n         * specified path.\n         */\n        get : function(path) {\n            return this._mapper.find(path);\n        },\n\n        /** Returns a list of all paths. */\n        getAllPaths : function() {\n            return _.keys(this._config);\n        },\n\n        /**\n         * Returns descriptions for all HTTP methods defined for the specified\n         * path.\n         */\n        getPathMethods : function(path) {\n            return this._config[path];\n        },\n\n        /** Exports the content of this descriptor as a JSON object. */\n        exportJson : function() {\n            var api = [];\n            var result = {\n                api : api\n            };\n            var that = this;\n            _.each(that._config, function(obj) {\n                _.each(obj, function(conf) {\n                    api.push(conf);\n                });\n            });\n            api.sort(function(a, b) {\n                return a.path > b.path ? 1 : a.path < b.path ? -1 : 0;\n            });\n            return result;\n        },\n\n        /** Imports the content of this descriptor from a JSON array. */\n        importJson : function(json) {\n            var that = this;\n            var array;\n            if (_.isObject(json) && _.isArray(json.api)) {\n                array = json.api;\n            } else {\n                array = _.toArray(json);\n            }\n            _.each(array, function(conf) {\n                that.add(conf.path, conf.http, conf.method, conf.options);\n            });\n        }\n\n    });\n\n    /**\n     * Normalizes paths - add the first slash and remove a trail separator. If\n     * the specified path is empty (or null) then this method returns an empty\n     * string.\n     */\n    function normalizePath(path) {\n        if (!path || path === '') {\n            path = '';\n        } else {\n            if (path[0] != '/') {\n                path = '/' + path;\n            }\n            if (path[path.length - 1] === '/') {\n                path = path.substring(0, path.length - 1);\n            }\n        }\n        return path;\n    }\n\n    /** Static methods */\n    _.extend(ApiDescriptor, {\n\n        /** Make this method publicly available. */\n        normalizePath : normalizePath,\n\n        /**\n         * Automatically creates an API descriptor by reading properties\n         * associated with methods of the specified class. If a method has\n         * string properties \"http\" and \"path\" then they are used to create a\n         * new entry for an API descriptor (\"path\", \"http\" and \"method\").\n         */\n        getDescriptor : function(service) {\n            var descriptor = new ApiDescriptor();\n            var json = ApiDescriptor.getDescriptorJson(service);\n            descriptor.importJson(json);\n            return descriptor;\n        },\n\n        /**\n         * Automatically creates a JSON object containing definition of the API.\n         * If a method of the specified class has string properties \"http\" and\n         * \"path\" then they are used to create a new entry for an API descriptor\n         * (\"path\", \"http\" and \"method\").\n         */\n        getDescriptorJson : function(service) {\n            var result = [];\n            service = _.isFunction(service) ? service.prototype : service;\n            _.each(_.functions(service), function(name) {\n                var method = service[name];\n                if (!method.http || !method.path)\n                    return;\n                var obj = {\n                    method : name,\n                    http : method.http,\n                    path : method.path\n                };\n                var hasOptions = false;\n                var options = {};\n                _.each(_.keys(method), function(key) {\n                    if (key != 'http' && key != 'path') {\n                        hasOptions = true;\n                        options[key] = method[key];\n                    }\n                });\n                if (hasOptions) {\n                    obj.options = options;\n                }\n                result.push(obj);\n            });\n            return result;\n        },\n\n        /**\n         * This method is used to bind \"path\" and \"http\" properties to the given\n         * class method. These properties are used to automatically create a\n         * ApiDescriptor instance from class (see the\n         * ApiDescriptor.getDescriptor and ApiDescriptor.getDescriptorJson).\n         */\n        bind : function(path, http, method, options) {\n            return _.extend(method, {\n                http : http,\n                path : path\n            }, options);\n        }\n    });\n\n    /**\n     * A common superclass for client/server handlers\n     * (ApiDescriptor.HttpClientStub and ApiDescriptor.HttpServerStub) executing\n     * API method calls.\n     */\n    var Handler = Class.extend({\n        /**\n         * Wraps the \"handle\" method of this class - adds notifications before\n         * and after that calls.\n         */\n        _wrapHandleMethod : function(handle) {\n            return function(req, res) {\n                var that = this;\n                return P.fin(P.then(function() {\n                    return that._beginHttpCall({\n                        req : req, // HTTP request\n                        res : res, // HTTP response\n                        stub : that, // Server or client stub\n                    });\n                }).then(function() {\n                    return handle.call(that, req, res);\n                }), function(err, result) {\n                    return that._endHttpCall({\n                        req : req, // HTTP request\n                        res : res, // HTTP response\n                        stub : that, // Server or client stub\n                        err : err, // HTTP error\n                        result : result, // Execution result\n                    });\n                });\n            };\n        },\n\n        /**\n         * This method is called just before calling an API method. By default\n         * this method try to call the 'beginHttpCall' method defined (if any)\n         * in the constructor parameters.\n         */\n        _beginHttpCall : function(params) {\n            if (_.isFunction(this.options.beginHttpCall)) {\n                this.options.beginHttpCall(params);\n            }\n        },\n\n        /**\n         * This method is invoked just after calling an API method. By default\n         * this method try to call the 'endHttpCall' method defined (if any) in\n         * the constructor parameters.\n         */\n        _endHttpCall : function(params) {\n            if (_.isFunction(this.options.endHttpCall)) {\n                this.options.endHttpCall(params);\n            }\n        },\n    });\n\n    /**\n     * HTTP server stub redirecting server-side calls to the real API\n     * implementation described by an ApiDescriptor instance.\n     */\n    ApiDescriptor.HttpServerStub = Handler.extend({\n\n        /** This suffix is used to define URLs returning API descriptions. */\n        INFO_SUFFIX : '.info',\n\n        /** Registers this server stub in the specified Express application. */\n        registerIn : function(app) {\n            var that = this;\n            var prefix = normalizePath(this.options.path) + '*';\n            app.all(prefix, function(req, res) {\n                that.handle(req, res).done();\n            });\n        },\n\n        /**\n         * Initializes this object and checks that the specified options contain\n         * an API descriptor.\n         * \n         * @param options.descriptor\n         *            an API descriptor defining all methods exposed via REST\n         *            endpoints; this descriptor defines mapping of path\n         *            parameters and used HTTP methods to call methods; if there\n         *            is no descriptor then this method tries to automatically\n         *            create a new one from the \"options.instance\" field using\n         *            the \"ApiDescriptor.getDescriptor\".\n         * @param options.instance\n         *            an instance implementing the API; all remote API calls are\n         *            delegated to this object; if this parameter is not defined\n         *            then this instance is used instead; see also the\n         *            \"_getInstance\" method of this class.\n         */\n        initialize : function(options) {\n            this.setOptions(options);\n            this.descriptor = this.options.descriptor;\n            if (!this.descriptor) {\n                var instance = this.options.instance || this;\n                this.descriptor = ApiDescriptor.getDescriptor(instance);\n            }\n            this.options.path = normalizePath(this.options.path);\n            this._doHandle = this._wrapHandleMethod(this._doHandle);\n        },\n\n        /**\n         * Returns an internal descriptor corresponding to this server stub.\n         */\n        getDescriptor : function() {\n            return this.descriptor;\n        },\n\n        /**\n         * Handles the specified HTTP request by calling a method corresponding\n         * to the request path.\n         * \n         * @param req\n         *            an HTTP request\n         * @param res\n         *            an HTTP response\n         */\n        handle : function(req, res) {\n            var that = this;\n            return P.then(function() {\n                return that._doHandle(req, res);\n            }).then(function(obj) {\n                res.status(200).send(obj || '');\n            }, function(err) {\n                var errObj = Errors.toJSON(err);\n                errObj.status = errObj.status || 500;\n                res.status(errObj.status).send(errObj);\n            });\n        },\n\n        /**\n         * Handles the specified HTTP request. This method is used by the\n         * \"handle\" method to perform real actions.\n         */\n        _doHandle : function(req, res) {\n            var that = this;\n            var path = ApiDescriptor.HttpServerStub.getPath(req);\n            path = that._getLocalizedPath(path);\n            if (that._isEndpointInfoPath(path)) {\n                var json = that.getEndpointJson();\n                return json;\n            } else {\n                var http = req.method.toLowerCase();\n                var conf = that.descriptor.get(path);\n                if (!conf) {\n                    throw Errors.newError('Path not found \"' + path + '\"')\n                            .code(404);\n                }\n                var info = conf.obj[http];\n                if (!info) {\n                    throw Errors.newError('HTTP method \"' + http.toUpperCase() + //\n                    '\" is not supported. Path: \"' + path + '\".').code(404);\n                }\n                var methodName = info.method;\n                var results = that._callMethod(req, res, methodName,\n                        conf.params);\n                var options = conf.obj.options;\n                if (options && options.headers && res.setHeader) {\n                    _.each(options.headers, function(header, key) {\n                        res.setHeader(key, header);\n                    });\n                }\n                return results;\n            }\n        },\n\n        /** Returns a JSON descriptor for the specified handler */\n        getEndpointJson : function() {\n            var that = this;\n            var descriptor = that.getDescriptor();\n            var json = descriptor.exportJson();\n            json.endpoint = that.options.path;\n            return json;\n        },\n\n        /**\n         * Returns true if the specified path corresponds to an API description\n         * endpoint. IE this endpoint should send a JSON description of all API\n         * methods available with this path prefix.\n         */\n        _isEndpointInfoPath : function(path) {\n            if (path === '' || path == '/')\n                return true;\n            var idx = path.lastIndexOf(this.INFO_SUFFIX);\n            return (idx >= 0 && idx === path.length - this.INFO_SUFFIX.length);\n        },\n\n        /**\n         * Returns an instance where the specified method should be invoked.\n         * \n         * @param req\n         *            HTTP request object\n         * @param res\n         *            HTTP response object\n         * @param method\n         *            the method to invoke\n         * @param urlParams\n         *            parameters defined in the URL path\n         */\n        _getInstance : function(req, res, method, urlParams) {\n            var options = this.options || {};\n            var instance = options.instance || this;\n            return instance;\n        },\n\n        /**\n         * Calls the specified method on the API implementation instance.\n         * \n         * @param req\n         *            HTTP request object\n         * @param res\n         *            HTTP response object\n         * @param method\n         *            the method to invoke\n         * @param urlParams\n         *            parameters defined in the URL path\n         */\n        _callMethod : function(req, res, method, urlParams) {\n            var that = this;\n            var instance = that._getInstance(req, res, method, urlParams);\n            var f = instance[method];\n            if (!f) {\n                throw Errors.newError(//\n                'Method \"' + method + '\" is not implemented')//\n                .code(500);\n            }\n            var params = that._getMethodParams(method, urlParams, req, res);\n            return f.call(instance, params);\n        },\n\n        /**\n         * This method aggregates all parameters defined in the HTTP request and\n         * transforms them in the parameter object used to invoke an API method.\n         * This method merges together parameters defined in the URL path,\n         * explicit request parameters, request body and request cookies. This\n         * method could be overloaded to re-define a set of parameters for\n         * methods.\n         */\n        _getMethodParams : function(method, urlParams, req, res) {\n            return _.extend({}, req.query, req.body, req.cookies, urlParams);\n        },\n\n        /**\n         * Returns a localized version of the specified path. This path is used\n         * to find an API method to invoke. Used internally by the \"_doHandle\"\n         * method.\n         */\n        _getLocalizedPath : function(path) {\n            var prefix = this.options.path;\n            return path.substring(prefix.length);\n        }\n    });\n\n    /** Extract and returns path from the given request object. */\n    ApiDescriptor.HttpServerStub.getPath = function(req) {\n        var path = req.path;\n        if (!path || path === '') {\n            var url = req.url || '';\n            // path = url.replace(/^.*(\\/.*)[?#\\/].*/i, '$1');\n            var idx = url.indexOf('?');\n            if (idx >= 0) {\n                url = url.substring(0, idx);\n            }\n            idx = url.indexOf('#');\n            if (idx >= 0) {\n                url = url.substring(0, idx);\n            }\n            idx = url.indexOf('/');\n            if (idx > 0) {\n                url = url.substring(idx);\n            }\n            path = url;\n        }\n        return path;\n    };\n\n    /**\n     * Http client stub generating API methods based on an ApiDescriptor\n     * instance and forwarding all method calls to a remote server by HTTP.\n     */\n    ApiDescriptor.HttpClientStub = Handler.extend({\n\n        /**\n         * Initializes this object and checks that the specified options contain\n         * an API descriptor and a base URL of the API endpoint to invoke.\n         * \n         * @param options.descriptor\n         *            a mandatory API descriptor defining all methods exposed\n         *            via REST endpoints; this descriptor defines mapping of\n         *            path parameters and used HTTP methods to call methods\n         * @param options.client\n         *            (or options.baseUrl) the HTTP client or a baseUrl used to\n         *            create a new HTTP client.\n         */\n        initialize : function(options) {\n            if (!options.descriptor) {\n                throw Errors.newError('API descriptor is not defined')\n                        .code(501);\n            }\n            var that = this;\n            that.setOptions(options);\n            that.descriptor = that.options.descriptor;\n            that.client = that.options.client || that._newHttpClient();\n            that.handle = that._wrapHandleMethod(that.handle);\n            var paths = that.descriptor.getAllPaths();\n            _.each(paths, function(path) {\n                var methods = that.descriptor.getPathMethods(path);\n                _.each(methods, function(conf, http) {\n                    var methodName = conf.method;\n                    that[methodName] = function(params) {\n                        var p = that._getFullPath(path, params);\n                        var req = that.client.newRequest({\n                            path : p,\n                            method : http,\n                            params : params\n                        });\n                        var res = that.client.newResponse(req);\n                        return that.handle(req, res);\n                    };\n                });\n            });\n        },\n\n        /**\n         * Handles the specified request to the remote API method and returns a\n         * promise with the response.\n         */\n        handle : function(req, res) {\n            return this.client.handle(req, res);\n        },\n\n        /**\n         * Creates and returns a new HTTP client (an instance of the HttpClient\n         */\n        _newHttpClient : function() {\n            return new HttpClient.newInstance(this.options);\n        },\n\n        /** Returns a full path for the specified method path. */\n        _getFullPath : function(methodPath, params) {\n            return PathMapper.formatPath(methodPath, params);\n        }\n    });\n\n    /**\n     * Loads API description and returns a client stub corresponding to the\n     * specified endpoint URL.\n     */\n    ApiDescriptor.HttpClientStub.load = function(baseUrl, options) {\n        if (_.isObject(baseUrl)) {\n            options = baseUrl;\n            baseUrl = options.baseUrl;\n        }\n        options = options || {};\n        var httpClient = new HttpClient.newInstance({\n            baseUrl : baseUrl\n        });\n        var req = httpClient.newRequest({\n            path : ''\n        });\n        var res = httpClient.newResponse(req);\n        return httpClient.handle(req, res).then(function(description) {\n            var apiInfo = description.api;\n            var descriptor = new ApiDescriptor();\n            descriptor.importJson(apiInfo);\n            var client = httpClient;\n            if (description.baseUrl && baseUrl !== description.baseUrl) {\n                client = new HttpClient.newInstance({\n                    baseUrl : description.baseUrl\n                });\n            }\n            return new ApiDescriptor.HttpClientStub(_.extend(options, {\n                path : description.endpoint,\n                descriptor : descriptor,\n                client : client,\n            }));\n        });\n    };\n\n    return ApiDescriptor;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/ApiDescriptor.js\n ** module id = 5\n ** module chunks = 0\n **/","if (typeof define !== 'function') {\n    var define = require('amdefine')(module);\n}\ndefine(\n// Dependencies\n[ 'require', 'underscore', 'mosaic-commons', // \n'./PathMapper', './ApiDescriptor' ],\n// Module\nfunction(require) {\n\n    var Mosaic = require('mosaic-commons');\n    var P = Mosaic.P;\n    var Errors = Mosaic.Errors;\n    var Class = Mosaic.Class;\n    var _ = require('underscore');\n    var PathMapper = require('./PathMapper');\n    var ApiDescriptor = require('./ApiDescriptor');\n\n    /**\n     * API dispatcher provides mapping between path prefixes and instances\n     * implementing server endpoints.\n     */\n    var ApiDispatcher = Class.extend({\n\n        /**\n         * Initializes this object.\n         * \n         * @param options.path\n         *            this path prefix is added to all endpoints\n         */\n        initialize : function(options) {\n            this.setOptions(options);\n            this.options.path = this._normalizePath(this.options.path);\n            this._mapping = new PathMapper();\n        },\n\n        /**\n         * Binds a new service to the path prefix.\n         * \n         * @param options.path\n         *            path prefix corresponding to the service methods\n         * @param options.instance\n         *            instance of the service instance handling requests\n         */\n        addEndpoint : function(options) {\n            var that = this;\n            var mask = that._prepareEndpointMask(options);\n            var handler = that._newServerStub(options);\n            that._mapping.add(mask, handler);\n        },\n\n        /**\n         * Removes an endpoint corresponding to the specified path.\n         */\n        removeEndpoint : function(path) {\n            var that = this;\n            return P.then(function() {\n                var mask = that._prepareEndpointMask({\n                    path : path\n                });\n                var result = that._mapping.remove(mask);\n                if (!result) {\n                    throw Errors.newError('No endpoint is registered ' + //\n                    'for this path. Path: \"' + path + '\".').code(404);\n                }\n            });\n        },\n\n        /**\n         * Handles the specified request by dispatching it to registered API\n         * endpoints.\n         */\n        handle : function(req, res) {\n            var that = this;\n            return P.then(function() {\n                var path = ApiDescriptor.HttpServerStub.getPath(req);\n                return that.loadEndpoint(path).then(function(handler) {\n                    if (!handler) {\n                        throw Errors.newError(404, //\n                        'API handler not found. Path: \"' + path + '\".');\n                    } else {\n                        return handler.handle(req, res);\n                    }\n                });\n            }).then(null, function(err) {\n                var errObj = Errors.toJSON(err);\n                errObj.status = errObj.status || 500;\n                res.send(errObj.status, errObj);\n            });\n        },\n\n        /**\n         * Loads information about an endpoint corresponding to the specified\n         * path.\n         */\n        loadEndpoint : function(path) {\n            var that = this;\n            return P.then(function() {\n                path = that._normalizePath(path);\n                var item = that._mapping.find(path);\n                if (item)\n                    return item;\n                return P.then(function() {\n                    return that._loadEndpoint(path);\n                }).then(function(options) {\n                    if (options) {\n                        that.addEndpoint(options);\n                        item = that._mapping.find(path);\n                    }\n                    return item;\n                });\n            }).then(function(item) {\n                return item ? item.obj : null;\n            });\n        },\n\n        /**\n         * Creates and returns a new server stub providing remote access to the\n         * given service instance.\n         */\n        _newServerStub : function(options) {\n            var instance = options.stub || options.instance;\n            if (!instance) {\n                throw Errors.newError('API implementation is not defined');\n            }\n            var handler;\n            if (ApiDescriptor.HttpServerStub.hasInstance(instance)) {\n                handler = instance;\n            } else {\n                handler = new ApiDescriptor.HttpServerStub(options);\n            }\n            return handler;\n        },\n\n        /**\n         * This method could overloaded in subclasses to load a service\n         * corresponding to the specified path. This method should return an\n         * options object to register a new endpoint using the \"addEndpoint\"\n         * method - it has contain the following fields 1) \"options.path\" - path\n         * prefix corresponding to the service methods 2) \"options.instance\" -\n         * instance of the service instance handling requests.\n         */\n        _loadEndpoint : function(path) {\n            return null;\n        },\n\n        /**\n         * Builds and returns a mask for an endpoint defined by the path options\n         * parameter.\n         */\n        _prepareEndpointMask : function(options) {\n            var that = this;\n            if (!options.path) {\n                throw Errors.newError('Path is not defined');\n            }\n            var idx = options.path.lastIndexOf('.');\n            if (idx >= 0) {\n                options.path = options.path.substring(0, idx);\n            }\n            options.path = that._normalizePath(options.path);\n            options.mask = options.path + '*prefix';\n            return options.mask;\n        },\n\n        /**\n         * Normalizes paths - add the first slash and remove a trail separator.\n         * If the specified path is empty (or null) then this method returns an\n         * empty string.\n         */\n        _normalizePath : function(path) {\n            if (!path || path === '') {\n                path = '';\n            } else {\n                if (path[0] != '/') {\n                    path = '/' + path;\n                }\n                if (path[path.length - 1] === '/') {\n                    path = path.substring(0, path.length - 1);\n                }\n            }\n            return path;\n        }\n    });\n\n    return ApiDispatcher;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/ApiDispatcher.js\n ** module id = 6\n ** module chunks = 0\n **/","if (typeof define !== 'function') {\n    var define = require('amdefine')(module);\n}\ndefine(\n// Dependencies\n[ 'require', 'underscore', 'mosaic-commons' ],\n// Module\nfunction(require) {\n\n    var Mosaic = require('mosaic-commons');\n    var Class = Mosaic.Class;\n    var _ = require('underscore');\n\n    /**\n     * This class is used to map path masks to objects. It allows to find\n     * nearest object matching to the given path. This class is useful to\n     * implement call routers.\n     */\n    var PathMapper = Class.extend({\n\n        /** Initialization of this object. */\n        initialize : function() {\n            var that = this;\n            that.handlers = [];\n        },\n\n        /**\n         * Adds a new object to this mapper.\n         * \n         * @param mask\n         *            path mask used to dispatch to this object\n         * @param obj\n         *            the object to add\n         */\n        add : function(mask, obj) {\n            var that = this;\n            var chunks = [];\n            var names = [];\n            var a = false;\n            _.each(mask.split('*'), function(segment) {\n                var b = false;\n                _.each(segment.split(':'), function(str) {\n                    if (!a && !b) {\n                        chunks.push(esc(str));\n                    } else if (a || b) {\n                        var idx = str.indexOf('/');\n                        var r = b ? '[^\\/]+' : '.*?';\n                        if (idx >= 0) {\n                            chunks.push(wrap(r));\n                            names.push(str.substring(0, idx));\n                            chunks.push(esc(str.substring(idx)));\n                        } else {\n                            chunks.push(wrap(r));\n                            names.push(str);\n                        }\n                    }\n                    b = true;\n                });\n                a = true;\n            });\n            var str = chunks.join('');\n            var regexp = new RegExp('^' + str + '$');\n            that.handlers.push({\n                mask : mask,\n                regexp : regexp,\n                names : names,\n                obj : obj\n            });\n        },\n\n        /**\n         * Finds and returns a nearest object corresponding to the given path.\n         * This method returns an object with two fields: 1) The 'obj' field\n         * contains the found object 2) The 'params' field contains all found\n         * path parameters (defined in the initial path mask used to register\n         * this object).\n         */\n        find : function(path) {\n            var that = this;\n            var result = null;\n            _.any(that.handlers, function(handler) {\n                if (!handler.regexp.test(path))\n                    return;\n                var params = {};\n                var regexp = handler.regexp.exec(path);\n                var array = regexp.slice(1);\n                var idx = 0;\n                _.each(array, function(param) {\n                    var name = handler.names[idx++];\n                    var value = param ? decodeURIComponent(param) : null;\n                    params[name] = value;\n                });\n                result = {\n                    params : params,\n                    obj : handler.obj\n                };\n                return true;\n            });\n            return result;\n        },\n\n        /**\n         * Removes and returns the mapped object corresponding to the specified\n         * path mask.\n         */\n        remove : function(mask) {\n            var that = this;\n            var result = null;\n            var removed = null;\n            that.handlers = _.filter(that.handlers, function(handler) {\n                var keep = true;\n                if (handler.mask === mask) {\n                    removed = handler.obj;\n                    keep = false;\n                }\n                return keep;\n            });\n            return removed;\n        }\n\n    });\n\n    /**\n     * A static method used to format a string based on the given path mask and\n     * specified parameters.\n     */\n    PathMapper.formatPath = function(mask, params) {\n        params = params || {};\n        var array = mask.split(/[:\\*]/gim);\n        var path = [];\n        for (var i = 0; i < array.length; i++) {\n            var segment = array[i];\n            if (i === 0) {\n                if (segment !== '') {\n                    path.push(segment);\n                }\n            } else {\n                var name = null;\n                var idx = segment.indexOf('/');\n                if (idx >= 0) {\n                    name = segment.substring(0, idx);\n                    segment = segment.substring(idx);\n                } else {\n                    name = segment;\n                    segment = null;\n                }\n                var value = params[name];\n                if (!value) {\n                    var msg = 'Required parameter \"' + name + '\" not defined.';\n                    var err = new Error(msg);\n                    err._code = 400;\n                    throw err;\n                }\n                delete params[name];\n                path.push(value);\n                if (segment && segment !== '') {\n                    path.push(segment);\n                }\n            }\n        }\n        return path.join('');\n    };\n\n    /** Regular expression used to find and replace special symbols. */\n    var escapeRegExp = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\n    /** Escapes the specified string */\n    function esc(str) {\n        return str.replace(escapeRegExp, '\\\\$&');\n    }\n    /** Transforms the given string in a Regexp group. */\n    function wrap(str) {\n        return '(' + str + ')';\n    }\n\n    return PathMapper;\n\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/PathMapper.js\n ** module id = 7\n ** module chunks = 0\n **/","if (typeof define !== 'function') {\n    var define = require('amdefine')(module);\n}\ndefine(\n// Dependencies\n[ 'require', 'underscore', 'superagent', './HttpClient' ],\n// Module\nfunction(require) {\n\n    var _ = require('underscore');\n    var HttpClient = require('./HttpClient');\n    var Superagent = require('superagent');\n\n    /**\n     * An implementation of the HttpClient interface based on the Superagent\n     * HTTP client library.\n     */\n    var HttpClientSuperagent = HttpClient.Superagent = HttpClient.extend({\n\n        initialize : function(options) {\n            var init = HttpClient.prototype.initialize;\n            init.call(this, options);\n        },\n\n        http : function(req, res, callback) {\n            var method = (req.method || 'get').toLowerCase();\n            if (method == 'delete') {\n                method = 'del';\n            }\n            method = method.toLowerCase();\n            var headers = _.extend({}, this.options.headers, req.headers);\n            var query = _.extend({}, this.options.query, req.query);\n            var body = _.extend({}, this.options.body, req.body);\n            if (req.params) {\n                if (method === 'put' || method === 'post') {\n                    _.extend(body, req.params);\n                } else {\n                    _.extend(query, req.params);\n                }\n            }\n            var agent = Superagent[method](req.url);\n            if (this.options.formEncoded) {\n                agent.type('form');\n            }\n            agent.set(headers).query(query).send(body).end(function(err, r) {\n                try {\n                    if (r) {\n                        res.status = r.status;\n                        _.extend(res.headers, r.headers || {});\n                        res.body = r.body ||r.text;\n                    } else if (err && err.status) {\n                        res.status = err.status;\n                    } else {\n                        res.status = 500;\n                    }\n                    callback(err);\n                } catch (e) {\n                    callback(e);\n                }\n            });\n        }\n    });\n\n    return HttpClientSuperagent;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/HttpClientSuperagent.js\n ** module id = 8\n ** module chunks = 0\n **/"],"sourceRoot":"","file":"mosaic-teleport.js"}